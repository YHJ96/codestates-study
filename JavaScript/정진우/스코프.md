# 스코프

Scope를 우리말로 번역하면 '범위’라는 뜻을 가지고 있습니다. 즉, **_스코프(Scope)란 변수에 접근할 수 있는 범위_** 라고 할 수 있는데요.

자바스크립트에선 스코프는 2가지 타입이 있습니다. 바로 **_global(전역)_** 과 **_local(지역)_** 인데요.

**_전역 스코프(Global Scope)는 말 그대로 전역에 선언되어있어 어느 곳에서든지 해당 변수에 접근할 수 있다는 의미_** 이고 **_지역 스코프(Local Scope)는 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에선 접근할 수 없다는 의미_** 입니다.

자바스크립트에서 **_함수를 선언하면 함수를 선언할 때마다 새로운 스코프를 생성하게 됩니다. 그러므로 함수 몸체에 선언한 변수는 해당 함수 몸체 안에서만 접근할 수 있는데요. 이걸 함수 스코프(function-scoped)라고 합니다. 함수 스코프가 바로 지역 스코프의 예_**라고 할 수 있습니다.

아래의 예제 코드를 통해 전역 스코프, 지역(함수) 스코프를 더 자세히 알아보겠습니다.

```javascript
var a = 1; // 전역 스코프
function print() {
  // 지역(함수) 스코프
  var a = 111; // <-
  console.log(a); // <-
}
print();
console.log(a);
```

위의 예제에서 print함수를 호출하면 console엔 1이 출력될까요? 아니면 111이 출력될까요?
print 함수를 호출하면 111이 출력되는 것을 볼 수 있습니다.

```javascript
var a = 1; // 전역 스코프
function print() {
  // 지역(함수) 스코프
  var a = 111;
  console.log(a);
}
print(); // 111
console.log(a); // 1
```

print 함수에서 console.log(a);는 a를 출력하기 위해 자신의 함수 스코프 안에 변수 a가 있는지 찾아볼 것입니다. 그러면 var a = 111; 을 찾아내면 111을 console에 출력하고 함수는 자신의 사명을 다하게 됩니다.  
만약 print 함수 안에 변수 a의 선언을 지운다면 console엔 어떤 값이 출력될까요? 함수 스코프 안에 a가 존재하지 않으니까 a가 선언되어있지 않다는 에러를 출력할까요? 한 번 print 함수를 다시 선언하고 실행해보겠습니다.

```javascript
var a = 1; // 전역 스코프

function print() {
  // 함수 스코프
  console.log(a);
}

print(); // 1
```

결과는 예상과는 다르게 전역 스코프에 선언되어있는 a의 값인 1이 출력되는 것을 확인할 수 있습니다. 이는 **_Scope Chain에 의해 일어나는 현상_** 인데요. 현재 **_자신의 scope에서 사용하고자 하는 변수가 없다면 Scope Chain을 통해 해당 변수를 찾게됩니다._** Scope Chain에 대한 이야기는 후에 다른 글에서 한번 더 정리를 해보도록 하겠습니다.
**_함수 스코프_** 외에 **_블록 스코프_** 란 것도 있는데요. **_블록(block)이란 중괄호로 둘러싸인 부분을 블록_** 이라고 합니다. **_함수를 선언할 때 중괄호로 함수 본문을 둘러싸게 되는데 이부분을 블록이라고 할 수 있습니다._**

```javascript
function print() {
  // 함수 블록
  console.log(a);
}

{
  // 블록
  const a = "1";
}
```

기존 var의 경우 함수 스코프를 가졌기 때문에 함수 내에서만 지역변수가 유지되는 문제가 있었는데요. ES2015(ES6)에서 let / const 키워드가 추가되면서 함수가 아닌 일반 블록에서도 지역변수를 선언할 수 있게 되었습니다.

> ## 스코프의 주요 규칙

1. **_안쪽 스코프에서 바깥쪽 스코프로 접근할 수 있지만 반대는 불가능하다._**

- 바깥쪽 스코프에서 선언한 식별자는 안쪽 스코프에서 사용 가능하다.
- 반면, 안쪽에서 선언한 식별자는 바깥쪽 스코프에서는 사용할 수 없다.

2. **_스코프는 중첩이 가능하다._**

- 스코프는 마치 중첩된 울타리와도 같다.

3. **_전역 스코프와 지역 스코프_**

- 가장 바깥쪽에 스코프를 **_전역 스코프(Golbal Scope)_** 라고 부른다.
- 전역이 아닌 다른 스코프는 전부 **_지역 스코프(Local Scope)_** 이다.

4. **_지역 변수는 전역 변수보다 우선순위가 더 높다._**

- 전역 스코프에서 선언한 변수는 **_전역변수_** 이다.
- 지역 스코프에서 선언한 변수는 **_지역변수_** 이다.
- **_지역 변수는 전역 변수보다 더 높은 우선순위_** 를 가진다

> ## 스코프의 종류

- 스코프의 두가지 종류 블록 스코프와 함수 스코프가 있다.
- 화살표 함수는 스코프가 아니다.
- **_주의해야할 점은 화살표 함수는 블록 스코프로 취급된다._**

> ## 스코프와 var, let, const 키워드

- 변수 **선언 키워드** 세 가지의 **‘차이점’** 그리고 **‘스코프 유효 범위’** 는 아래와 같다.

1. const

- 유효 범위 : 블록 스코프 / 함수 스코프
- 값 재할당 : 불가능
- 재선언 : 불가능

2. let

- 유효범위 : 블록 스코프 / 함수 스코프
- 값 재할당 : 가능
- 재선언 : 불가능

3. var

- 유효 범위 : 함수 스코프
- 값 재할당 : 가능
- 재선언 : 가능

![Alt text](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/06/const-vs-let-vs-var.png?resize=480%2C249&ssl=1)

- 블록 스코프 안에서 **_let, const 키워드_** 로 선언한 변수는 **_스코프 안에서만 참조 가능하다._**
- 그런데 **_var 키워드_**로 선언한 변수는 **_블록 스코프를 무시_** 하고 스코프 울타리 밖에서도 접근 가능하다.(var는 Only 함수 스코프만 따른다.)

```javascript
for (let i = 0; i < 10; i++) {
  console.log(i);
}
// 전역스코프에서 선언한 변수 i 는 존재하지 않음으로 아래에서 ReferenceErrer을 일으킨다.
console.log(i); // ReferenceErrer
```

- **var 키워드**로 선언한 변수는 only **_'함수 스코프'_** 만을 따른다.

```javascript
for (var i = 0; i < 10; i++) {
  console.log(i);
}
// var 키워드로 선언한 변수 i 는 지역 스코프에서 선언되었지만 모든 스코프에서 접근 가능하다.
console.log(i); // 9
```

> ❗️ **_그러나 블록 단위로 스코프를 구분했을 때, 훨씬 더 예측 가능한 코드를 작성할 수 있으므로 let 키워드의 사용이 권장된다._**

---

> # 스코프와 관련해서 변수 선언시 주의점

## 전역 객체(window)의 이해

- Window 객체는 only 브라우저에만 존재하는 객체이다.
- 브라우저의 창(window)를 의미하는 객체이다.
- 그런데 별개로 전역 영역을 담고 있기도하다.
- 그래서 함수 선언식으로 함수를 선언하거나 var 키워드로 변수를 선언하면 window 객체에 속해진다.

  ![Alt text](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/05/%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%89%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AB-var%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE.png?resize=480%2C426&ssl=1)  
  전역에 var 키워드로 선언한 변수, a / 전역에 let키워드로 선언한 변수, b

  ***

  ![Alt text](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/05/%E1%84%8C%E1%85%A5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%E1%84%8B%E1%85%A6-%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%8B%E1%85%B4%E1%84%92%E1%85%A1%E1%86%AB-%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE.png?resize=480%2C423&ssl=1)  
  전역에 함수 선언식으로 등록한 함수, myFn()

  ***

## 전역 변수는 최소화하기

- 가장 바깥 스코프에 정의한 변수가 전역 변수이다.
- 즉, **_어디서든 접근이 가능하다._**
- 전역 변수를 최소화 하면 **_side effect(의도하지 않은 로직에 의해 문제 발생)_** 를 줄일 수 있다.
- 그런데 그러한 전역 변수를 **_심지어 var로 선언하는 경우 문제_** 가 될 수 있다.
  - 전역 변수는 어디서나 접근이 가능하다.
  - var 키워드는 블록 스코프를 무시한다.
  - 재선언과 재할당을 할 수 있다.
  - 전역 변수를 var로 선언해서 브라우저의 내장 기능을 못하게 만들 수도 있다.

## 선언 없는 변수 할당 금지

- 선언 없이 변수를 할당하면 해당 변수는 **_var로 선언한 전역 변수 처럼 취급_** 된다.
- 실수를 방지하기 위해 Strict Mode를 사용할 수 있다.
- **_Strict Mode_** 는 브라우저가 보다 엄격하게 작동하도록 만들어준다.
- “선언 없는 변수 할당”의 경우도 에러로 판단해준다.
- 적용하려면, **_js 파일 상단에 ‘use strict’라고 입력_** 하면된다. (따옴표 포함)
