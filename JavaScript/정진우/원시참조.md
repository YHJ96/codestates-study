# 원시 자료형과 참조 자료형

자바스크립트의 변수타입에는 크게 **_Primitive type(원시타입)_** 과 **_Reference Type(참조타입)_** 으로 나누어져 있다.

- **원시타입(Primitive type)** 의 변수들은 데이터 복사가 일어날 때 메모리 공간을 새로 확보하여 독립적인 값을 저장하며
- **참조타입(Reference type)** 은 직접 접근이 아닌 메모리의 위치(주소)에 대한 간접적인 참조를 통해 메모리에 접근하는 데이터 타입이다.

![Alt text](https://t1.daumcdn.net/cfile/tistory/991FB43F5D65F9AD21)

> ## 원시 자료형은 불변성(immutable)을 갖고있다.
>
> 자바스크립트에서 원시 타입 **_(string, number, bigint, (null), boolean, undefined, ES6 부터 추가된 symbol)_** 은 변수에 할당될 때, 메모리의 고정 크기로 원시 값을 저장하고 해당 저장된 값을 변수가 직접적으로 가리키는 형태를 띈다. 또한 값이 절때 변하지않는 불변성을 갖고있기때문에 때문에 재할당 시 기존 값이 변하는것 처럼 보일지 몰라도 사실 새로운 메모리에 재할당한 값이 저장되고 변수가 가리키는 메모리가 달라졌을 뿐이다.

```javascript
let a = 100; // a란 변수에 100이란 값을 할당
a = 50; // 50으로 재할당
```

첫 라인이 실행되면 메모리에 Number타입의 100이란 값이 생성되고 식별자 a는 메모리에 생성된 100의 메모리 주소를 가리킨다. 그후 두번째 라인이 실행되면 이전에 메모리에 생성된 100이란 값이 50으로 수정되는것이 아닌, 새로운 Number타입의 50이란 값을 새로운 메모리에 생성하고 a가 가리키던 메모리가 바뀌는것이다.  
![Alt text](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2F5e197937-108e-4f9c-8be8-0c8c04d3fe8e%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.02.57.png)  
메모리에는 100과 50이란 값이 모두 존재하고 있으며, 앞에서 말했듯이 원시타입은 불변성을 갖고 있기 때문에 기존에 메모리에 생성된 값들은 그 자체가 변경될 수 없다. 그저 식별자와 연결 되있는 메모리가 바뀌었기에 우리 눈에는 재할당 된 것처럼 보일뿐이다.

> ## 원시타임의 값이 복사 될때는 어떤 일이 일어나는지 알아보자.

```javascript
let a = 100;
let b = a;
a = 50;

console.log(b); // 100
```

![Alt text](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2F4c48d687-2e50-42d0-a72a-28058f114cd1%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-18%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.01.34.png)  
새로운 변수 b에 a를 할당 하게되면 변수 b의 공간에는 a의 값을 값을 통째로 복사하여 변수의 메모리에 담게 된다. 그렇기에 변수 a가 50으로 재할당 되더라도 b는 전혀 영향을 받지 않는다.

## **_원시자료형(primitive type)_**

```javascript
let name; // name 이라는 이름이 붙은 개인 사물함이 생긴다.
name = "suri"; // name 사물함을 찾아 'suri'라는 값을 넣어준다.

let age;
age = "22";
age = name;
console.log(name); // name의 값은 변하지 않는다.
```

- 변수에 값 자체가 담긴다.
- 고정된 저장 공간을 차지하는 데이터다.
- `number`, `boolean`, `null`, `undefined`, `string`, `symbol` 타입이 여기에 해당한다.
- 새로운 변수를 만들어 기존 변수 값을 할당해도 (복사) 기존의 변수값을 바뀌지 않는다.

---

## 원시타입을 제외한 나머지는 참조 타입이다.

자바스크립트에서 원시 타입을 제외한 나머지는 참조타입(객체(Object))이라 할 수 있다. 배열과 객체, 그리고 함수가 대표적이며, 원시타입과 가장 큰 차이점은 변수의 크기가 동적으로 변한다는 것이다. 이러한 특징 때문에 Object의 데이터 자체는 별도의 메모리 공간(heap)에 저장되며, 변수에 할당 시 데이터에 대한 주소 ( 힙(Heap) 메모리의 주소값)가 저장되기 때문에 자바스크립트 엔진이 변수가 가지고 있는 메모리 주소를 이용해서 변수의 값에 접근하게 되는것이다.

![Alt text](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2F6576b5c3-a064-4f24-a96f-b287b46c2aab%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.45.04.png)

> ### 만일 let myArray = []라는 배열을 생성하면 위와 같은 일이 일어난다. 그림에서 볼 수 있듯이 원시타입의 값들은 값들이 직접적으로 저장되어 있지만, myArray (참조타입)는 Heap 메모리의 주소값이 저장되어 있다.

```javascript
let myArr = [];
let copyArr = myArr;

myArr.push("hello");

console.log(copyArr); // ["hello"]
```

![Alt text](https://velog.velcdn.com/images%2Fnomadhash%2Fpost%2Fac894f26-b94a-41f8-990e-8b44c6775d97%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-09-16%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.54.37.png)  
위 예제를 보면 알 수 있듯이, 참조 타입의 변수는 실제 데이터가 저장된 주소를 참조하기에 참조(reference) 타입이라고 불리는 것이다. 그렇기에 변수의 복사나 수정 시 참조 여부를 잘 고려해야 한다. 만일 이러한 특성을 고려하지 않은 채 중요한 정보를 담고있는 객체나 배열에 수정 및 복사를 가하게되면 원본 데이터가 예상치 못한 방향 으로 변경될 수 있으므로 항상 이를 고려하자.

## **_참조 자료형(reference type)_**

```javascript
let arr = [1, 2];
let newArr = arr; // 주소 값이 복사되므로 같은 배열을 가리키게 된다.
newArr[0] = 3;
arr[0] = 3; // 원본 배열의 값도 변경이 된다.
```

- 참조 자료형이 할당될 때는 보관함의 주소(reference)가 담긴다.
- 특별한 저장 공간을 사용하기 때문에 저장공간이 유동적으로 계속 늘어날 수 있다.
- 사물함 아래 heap 이라는 빈 공간을 만들고, 사물함에는 주소를 담는다. 그리고 해당 주소에 값을 줄줄이 담는다.
- 배열, 객체, 함수 타입이 여기에 해당한다.
- 자바스크립트에서는 원시 자료형이 아닌 모든 것은 Object 이다.
- 새로운 변수를 만들어 기존 변수 값을 할당하면 주소값이 복사 된다. 그 상태에서 새로운 변수의 값을 변경하면 기존 변수의 값도 바뀌게 된다.

> ## 원시자료형 심화 📝

- 원시 자료형은 데이터가 하나의 정보만들 담고 있다. 옛날에는 데이터 저장소 용량이 제한되어 변수 하나에 하나의 원시 자료형 밖에 담을 수 밖에 없었다.
- 원시 자료형이 담기는 보관함의 크기는 고정하는 것이 합리적이다.
- 원시 자료형은 값 자체에 대한 변경은 불가능하지만, 변수에 다른 데이터를 할당할 수는 있다.
- 변수 하나에 값 하나 원시자료형은 심플하다.

```javascript
let words = "beautiful world!";
words = "wonderful world!"; // 재할당. const 키워드로 선언하면 재할당 불가
```

> ## 참조자료형 심화 📝

- 변수에 넣을 수 있는 데이터의 크기가 제한되기 때문에, 자료 구조를 따로 구현했다. 배열과 객체같이 데이터의 크기가 동적으로 변하는 특별한 데이터 보관함이 필요했다.
- 참조 자료형에는 하나의 데이터가 아닌 여러 데이터가 담기게 된다. 어떻게?
- 동적으로 변하는 특별한 데이터 보관함(heap)을 만들고 변수에는 그 보관함을 찾아갈 수 있는 주소를 변수에 저장한다.
- 변수가 가리키고 있는 데이터를 참조한다고 해서 참조 자료형이다. 주소를 참조하여 그 데이터를 비로소 읽어온다.
- 대량의 데이터의 경우 고정된 데이터 공간을 사용하는 것은 비효율적이다.
- 참조 자료형은 기존에 고정된 크기의 보관함이 아니라, 동적으로 크기가 변하는 특별한 보관함을 사용할 수 있다.

```javascript
let x = { foo: 3 };
let y = x;
y.foo = 2; // x와 y는 똑같은 데이터를 바라보고 있다.

let player = { score: 3 };
function doStuff(obj) {
  obj.score = 2;
}

doStuff(player);
// 함수가 호출되면 (실행되면) 매개변수 obj에 player의 값이 할당된다.
// 즉, { score: 3 }의 주소값이 할당된다.
```
